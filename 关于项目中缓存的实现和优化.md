# CKYSTemplate
## 关于项目中缓存的实现和优化

```
关于项目中缓存的实现和优化
缓存的目的在于性能优化，
   客户端缓存主要分为
    1. 内存缓存
    2. 磁盘缓存
    
关于内存缓存
1. 内存缓存的应用场景
    1. 内存缓存是为了通常有两个场景，
        1. 减少请求，减轻服务端压力
        2. 降低磁盘读取频次，提升性能
        
    
    1. 数据修改频次比较低的磁盘数据
        如：用户登录之后的数据结构，存储用户头像 昵称 id..., 这部分数据一般会存在磁盘中，使用时从磁盘中拿出来。
           
           1. 目前创客和商城项目就是存储在plist中每次都去从plist中获取（性能差）
           
           2. 用户登录登出操作的频率是最低的，而且这部分数据在跟多业务模块中都会用到, 请求好多接口需要传递用户ckid，而ckid 在用户登录之后是一个固定值，并不会变更
            
            3. 因此这部分数据可以在登录之后写入磁盘之后存储在内存中，作为一个全局变量去使用。 如果用户退出登录那么就监听用户登录登出操作去修改内存中变量，并修改磁盘中对应数据，用户不退出，重启app 会从磁盘中读到内存中保存一份
           
           4. 不管是哪个页面，哪个业务，哪个接口需要这份数据直接使用内存中数据即可，无需从磁盘或文件中读取。
        
    2. 减少网络请求 减轻服务端压力
        比如，在创客-素材中心-打赏-模块有一个场景
            用户A从服务端获取自己有100云豆，打赏用户B 10 云豆,成功之后，还想打赏用户C
            
            此时业务类在内存中需要存储一份用户A的云豆数据 ，
            
            1. 只在进入素材中心之后进行一次网络请求，请求服务端获取云豆数，
            int ck_user_a_money = 100; //服务端获取云豆数
            
            2. 打赏操作成功之后客户端根据内存中的数据进行计算，
            用户A打赏完用户B之后再去打赏用户C，此时可打赏金额为第一次请求获取的云豆减去打赏B的云豆，
            ck_user_a_money = ck_user_a_money - 10;
        
            3. 打赏完C 20 云豆之后A的云豆为ck_user_a_money = 90减去打赏C 20的云豆。
            ck_user_a_money = 90 - 20 = 70;
            直到用户A退出素材中心模块，重新进入采取请求服务端端获取可打赏金额。
        
            这样有一个不算弊端的弊端，一个用户多设备登录，同时打赏多个用户，客户端计算 就不准确了，其实这个操作频率极低，只有测试这么干，如果真有用户这么操作也没关系，服务端有氢气队列，客户端发出去的请求服务端会去查询DB真实数据，如果客户端想打赏用户20云豆，服务端查询发现用户没有这么多，那么会提示用户。用户就会疑问，返回上级页面再进来就获取最新数据，如果每次打赏成功之后都去请求服务端获取最新可打赏金额，服务端就亚历山大了。


2. 磁盘缓存
    磁盘缓存又分为 文件 DB 沙盒
    1. 文件 适用于大量数据，无需修改，存储覆盖，
        比如：从服务端端获取用户素材中心发布协议数据，1000字 大约 2KB
        
        1. 如果存在plist中不服符合苹果 对plist的使用场景，小量数据（不推荐）
        2. 如果存储在DB中未面浪费DB，大材小用（不推荐）
        3. 归档 适用有数据结构的对象类型（不推荐）
        4. 因此文件时最合适的方案，每次请求到数据之后只需要覆盖文件即可，进入需要的业务模块从文件中读取即可。不进行多次请求，不进行多次写入操作，随用随取，在合适不过。（强烈推荐）
        
  2. DB 结构复杂，客户端需要随时修改的数据
     比如：订单数据
     1. 订单数据是一个复杂的数据结构，如果使用文件存储，每次都进行文件覆盖，其实只需要修改其中某一条数据的一个字段，太浪费。（不推荐）
     2. 归档解档和文件一样无法修改某一条数据的某一个字段（不推荐）
     3. plist 不适合存储大量数据（不推荐）
     4. DB 是最合适的方案
        列表中有二十条订单数据，用户操作一条订单，单条订单状态修改，如果需要获取最新的订单列表，有两种方案
        1. 重新请求订单列表接口 获取最新订单数据，刷新 磁盘和内存（不推荐）
        2. 根据变更订单id请求变更订单数据，服务端只返回变更状态的订单数据
            优势：
            1. Http请求包体积减小，减少网络拥堵，提升请求效率，为用户省流量，低碳环保
            2. 客户端获取到单条数据，根据id 去DB中查找，update单条数据即可，在内存中replace 指定id 的item 即可  

```
