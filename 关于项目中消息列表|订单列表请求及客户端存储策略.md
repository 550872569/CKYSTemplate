# CKYSTemplate
## 关于项目中消息列表|订单列表请求及客户端存储策略

```
关于项目中消息列表|订单列表请求及客户端存储策略

1. 消息列表
   
   实际业务逻辑
   
   1. 消息列表数据在ck_server
        list<LastMessageItem>
        
        LastMessageItem {userId, userHeadUrl, userNameString... }
        
   2. ck_client_A：创客客户端 sc_clinet_B：商城客户端 
   
        1. ck_user_A 发送给 sc_user_B 一条消息，
            1. 在会话页面， ck_client_A知道
        2. sc_user_B 发送给 ck_user_A 一条消息，
            1. 在会话页面， ck_client_A知道
        3. sc_user_C 发送一条消息 给ck_user_A
            1. 在会话页面， ck_client_A知道
                                    
    消息列表数据的时效性要求比较高，用户之间进行交流消息随时可能会变更，
   
2. 订单列表
            
    orderList<OrderItem>
    
    order_A order_B ... order_N
    
    我的订单： SellerOrder  消费者订单： BuyerOrder
    
    无论是 SellerOrder 还是 BuyerOrder，在订单列表
    1. 由客户端发起的订单状态变更数据客户端是知道的，
        例如： 
        1. 创客自己购买操作，新增一条订单，     待付款
        2. 创客自己支付操作，变更 已支付，      待发货
        4. 创客自己收货操作，变更为            已收货 
        
        6. 创客自己退货操作，变更为            退货中

        对于这部分数据，可以 对原有 接口新增 时间戳字段 用于验证客户端数据是否失效，使用接口请求服务端 传递 changeOrderList   {orderId,timeStamp}
        
        服务端根据 orderId 去查询DB 数据，根据timeStamp 去筛选变更数据返回客户端，客户端再根据 服务端返回数据 去刷新UI，

    2. 服务端进行控制的状态，客户端需要请求接口从服务端获取最新订单状态
        3. 用户支付完成，发货操作是由服务端决定   已发货
        5. 服务端 确定用户收货成功             已完成

        7. 服务端 确定 退货操作，变更为         退货完成
    
        对于这部分数据，客户端请求原有接口去分页加载数据，下拉刷新操作可以获取到最新的订单list 
        
    
    由于订单列表数据对时效性要求比较高，因此在进入订单列表需要请求一次接口获取最新数据，如果客户端每次都去获取数据则是保证了数据的时效性，却对服务端造成压力，如果客户端不做缓存在用户进入页面却不能展示数据，体验不好，即便不是最新数据，用户在订单列表点击进入详情页面之后也会看到最新数据。
    
    因此建议如下：
    1. 参考商城App 订单列表作为二级页面，不在一级页面展示，用户点击订单入口按钮之后进入订单列表页面，进入之后请求数据，用户看到订单列表数据即便不是最新数据点击进入详情页面也会实时获取到服务端最新数据
 
    2. 拿到数据之后缓存到本地，为下次断网展示使用，即便数据已经不是最新数据，用户可以根据下拉刷新进行请求最新数据，减少因为用户切换页面而进行请求。如果用户没有开启网络，就无法获取到服务端最新数据，所以时效性无论如何都无法保证
    
    3. 服务端对客户端 新增接口 时间戳字段 用于验证客户端数据是否失效，使用接口请求服务端 传递 changeOrderList   {orderId,timeStamp}服务端根据 orderId 去查询DB 数据，根据timeStamp 去筛选变更数据返回客户端，客户端再根据 服务端返回数据 去刷新UI
    
    
    
```


